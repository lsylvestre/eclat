## Hardware implementation of OCaml using a synchronous functional language

**Sylvestre et al., PADL 24 paper**

This artefact, presented in the paper, includes:
- a compiler for the Eclat language
- an implementation of the OCaml virtual machine (VM) in Eclat (`ocaml-vm/`);
- the benchmarks from the paper (`benchs/`), with also hardware-accelerated 
  versions (e.g., `benchs/gcd/README.md`) and instructions to reproduce;
- Eclat examples (listings) from the paper, with execution traces (e.g. `examples/sum.png`) and instructions to reproduce;
- a folder `target` in which are generated:
  * a main component `main.vhdl`,
  * a testbench `tb_main.vhdl` (for simulation)
  * and an interface `synth/intel/top.vhdl` (for synthesis);
  
Eclat instantaneous primitives are defined in `target/runtime.vhdl`


The paper compares our VM implementation (the `ocaml/vm`folder) with an other implementation of the OCaml VM, called OMicroB ([https://github.com/stevenvar/OMicroB](https://github.com/stevenvar/OMicroB)) and a port of OMicroB on FPGA ([https://github.com/jserot/O2B](https://github.com/jserot/O2B))

-------------------

The VM includes :
- a configuration file (`ocaml-vm/bytecode.ecl`) generated by our auxiliary `ocaml-vm/gen_bytecode` from the output of the OCaml bytecode compiler;
- value representation (`ocaml-vm/vm/mlvalues.ecl`);
- dynamic memory in a static array (`ocaml-vm/vm/ram.ecl`);
- a memory allocator with garbage collector Stop&Copy  (`ocaml-vm/vm/alloc.ecl`);
- the primitives of the bytecode interpreter (`ocaml-vm/vm/runtime.ecl`);
- external primitives (`ocaml-vm/vm/prims.ecl`);
- a bytecode interpreter (`ocaml-vm/vm/vm.ecl`);
- some definitions for physical I/Os (`ocaml-vm/vm/target-specific/intel-max10/IOs.ecl`);
- a reactive program executing the VM internally (`ocaml-vm/vm/target-specific/intel-max10/main.ecl`).


Installation
------------

To build from source, the pre-requisites are:

* `opam` 
* `ocaml 4.14.1`
* `menhir`
* `ocamlclean`
* `obytelib`
* `dune`
* for simulation: `ghdl` and `GTKWave`
* for synthesis: `Intel Quartus II 22.1 lite`, on a 
  Terasic DE10-lite board (having an Intel MAX 10 FPGA)


Quick example (in simulation mode)
-------

```
$ make SRC=ocaml-vm/tests/fibo.ml
$ make simul NS=200000

...

pc:19|acc:55<int>|sp:1011|env:4000<ptr> 
pc:20|acc:89<int>|sp:1010|env:4000<ptr> 
pc:19|acc:89<int>|sp:1006|env:4000<ptr> 
pc:20|acc:144<int>|sp:1005|env:4000<ptr> 
pc:30|acc:144<int>|sp:1001|env:1<int> 
======> 144
pc:32|acc:1<int>|sp:1001|env:1<int> 
pc:34|acc:1<int>|sp:1000|env:1<int> 
STOP : cycle:16427 
pc:34|acc:1<int>|sp:1000|env:1<int> 
cycle:16428 
cycle:16429 
STOP : cycle:16430 
pc:34|acc:1<int>|sp:1000|env:1<int> 
^C
$
```

Synthesis (on DE-10 lite FPGA board)
-------

```
$ make FLAGS=" -intel-max10" SRC=ocaml-vm/tests/blink.ml
$ cd <QUARTUS-PATH>/bin
$ quartus
 
  - Processing > Start Compilation

  - Tools > Programmer > Start

  If USB-Blaster is not found:
  $ killall jtagd
  $ jtagd
  $ jtagconfig
```


